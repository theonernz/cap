// ==================== þ╗ÿÕêÂÕç¢µò░ ====================
const DrawingSystem = {
    canvas: null,
    ctx: null,
    gameWidth: 0,
    gameHeight: 0,
    
    // ÕêØÕºïÕîûþ╗ÿÕêÂþ│╗þ╗ƒ
    init(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
    },
    
    // Þ«¥þ¢«þö╗Õ©âÕñºÕ░Å
    setSize(width, height) {
        this.gameWidth = width;
        this.gameHeight = height;
        this.canvas.width = width;
        this.canvas.height = height;
    },
    
    // þ╗ÿÕêÂµ©©µêÅÕ©º
    drawFrame(mainPlayer, players, aiSeagulls, scallops, powerTransferEffects, zoomLevel) {
        // µ©àÚÖñþö╗Õ©â
        this.ctx.clearRect(0, 0, this.gameWidth, this.gameHeight);
        
        // þ╗ÿÕêÂÞâîµÖ»
        this.ctx.fillStyle = '#87CEEB';
        this.ctx.fillRect(0, 0, this.gameWidth, this.gameHeight);
        
        if (mainPlayer && !mainPlayer.isDead) {
            this.ctx.save();
            this.ctx.translate(this.gameWidth / 2, this.gameHeight / 2);
            this.ctx.scale(zoomLevel, zoomLevel);
            
            // µÀ╗Õèáþø©µ£║ÕüÅþº╗´╝êÞÀƒÚÜÅþÄ®Õ«Â´╝ë
            const cameraOffsetX = mainPlayer.velocityX * 10;
            const cameraOffsetY = mainPlayer.velocityY * 10;
            const maxOffset = 150;
            const actualOffsetX = Math.max(-maxOffset, Math.min(maxOffset, cameraOffsetX));
            const actualOffsetY = Math.max(-maxOffset, Math.min(maxOffset, cameraOffsetY));
            
            this.ctx.translate(-mainPlayer.x + actualOffsetX, -mainPlayer.y + actualOffsetY);
            
            // þ╗ÿÕêÂµ░┤ÞâîµÖ»
            this.drawWaterBackground();
            
            // þ╗ÿÕêÂµëçÞ┤Ø
            scallops.forEach(scallop => {
                this.drawScallop(scallop.x, scallop.y, scallop.currentSize || scallop.size, scallop.color, scallop.innerColor, zoomLevel, scallop.isGrowing, scallop.growthProgress, scallop);
            });
            
            // þ╗ÿÕêÂAIµÁÀÚ©Ñ
            aiSeagulls.forEach(seagull => {
                if (!seagull.isDead) {
                    this.drawSeagull(seagull, false, zoomLevel, mainPlayer);
                }
            });
            
            // þ╗ÿÕêÂþÄ®Õ«Â
            players.forEach(player => {
                if (!player.isDead) {
                    this.drawSeagull(player, player.isControllable, zoomLevel, mainPlayer);
                }
            });
            
            // þº╗ÚÖñõ©ûþòîÕØÉµáçþ│╗õ©¡þÜäµòêµ×£þ╗ÿÕêÂ´╝îÚü┐Õàìõ©ÄÕ▒ÅÕ╣òÕØÉµáçÚçìÕñìÕ»╝Þç┤ÚçìÕ¢▒
            // this.drawPowerTransferEffectsWorld(powerTransferEffects, zoomLevel, mainPlayer);
            
            this.ctx.restore();
        }
        
        // õ╗àÕ£¿Õ▒ÅÕ╣òþ®║Úù┤þ╗ÿÕêÂµòêµ×£´╝îÚü┐ÕàìÚçìÕ¢▒
        this.drawPowerTransferEffectsScreen(powerTransferEffects, zoomLevel, mainPlayer);
    },
    
    // þ╗ÿÕêÂµÁÀÚ©Ñ´╝êõ┐«ÕñìµûçÕ¡ùÚçìÕ¢▒´╝ë
    drawSeagull(entity, isControllable, zoomLevel, mainPlayer) {
        // õ©ûþòîÕ░║Õ»©´╝êõ©ìÚ£ÇÞªüµëïÕè¿õ╣ÿõ╗Ñ zoomLevel´╝îÕøáõ©║ canvas ÕÀ▓þ╗ÅÞó½ scale õ║å´╝ë
        const baseSize = entity.size * 10;            // õ©ûþòîÕìòõ¢ì
        const size = baseSize;                         // Õ£¿õ©ûþòîÕØÉµáçþ│╗õ©¡þ╗ÿÕêÂ´╝îõ©ìÚ£ÇÞªüÚóØÕñûþ╝®µö¥
        const x = entity.x;
        const y = entity.y;
        const wingFlapOffset = Math.sin(entity.wingFlapSpeed) * 5;
        
        // þ╗ÿÕêÂµÁÀÚ©ÑÞ║½õ¢ô
        this.ctx.fillStyle = entity.color;
        this.ctx.beginPath();
        this.ctx.ellipse(x, y, size, size * 0.7, 0, 0, Math.PI * 2);
        this.ctx.fill();
        
        // þ╗ÿÕêÂÕñ┤Úâ¿
        this.ctx.beginPath();
        this.ctx.ellipse(x + size * 0.8, y - size * 0.3, size * 0.5, size * 0.5, 0, 0, Math.PI * 2);
        this.ctx.fill();
        
        // þ╗ÿÕêÂþ£╝þØø
        this.ctx.fillStyle = '#000';
        this.ctx.beginPath();
        this.ctx.arc(x + size * 1.0, y - size * 0.3, size * 0.15, 0, Math.PI * 2);
        this.ctx.fill();
        
        // þ╗ÿÕêÂÕÿ┤ÕÀ┤
        this.ctx.fillStyle = '#FF9800';
        this.ctx.beginPath();
        this.ctx.moveTo(x + size * 1.3, y - size * 0.3);
        this.ctx.lineTo(x + size * 1.6, y - size * 0.3);
        this.ctx.lineTo(x + size * 1.3, y);
        this.ctx.closePath();
        this.ctx.fill();
        
        // þ╗ÿÕêÂþ┐àÞåÇ
        this.ctx.fillStyle = entity.color;
        this.ctx.beginPath();
        this.ctx.ellipse(
            x - size * 0.5, 
            y + size * 0.2 + wingFlapOffset, 
            size * 0.8, 
            size * 0.4, 
            Math.PI/4, 
            0, 
            Math.PI * 2
        );
        this.ctx.fill();
        
        // þ╗ÿÕêÂÕàëþÄ»µòêµ×£´╝êÕªéµ×£µÿ»ÕÅ»µÄºþÄ®Õ«Â´╝ë
        if (isControllable) {
            const haloColor = entity.isBoosting ? 'rgba(255, 50, 50, 0.6)' : 'rgba(255, 215, 0, 0.5)';
            this.ctx.strokeStyle = haloColor;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size + 5, 0, Math.PI * 2);
            this.ctx.stroke();
            
            if (entity.isBoosting) {
                this.ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size + 8, 0, Math.PI * 2);
                this.ctx.stroke();
            }
        }
        
        // þ╗ÿÕêÂÞâ¢ÕèøÕÇ╝µØí´╝êõ¢┐þö¿Õ»╣µò░Õê╗Õ║ª´╝îÚÇéÕ║öµùáÚÖÉÕó×Úò┐´╝ë
        // õ¢┐þö¿Õ»╣µò░µØÑÞ«®Ú½ÿÞâ¢ÕèøÕÇ╝õ╣ƒÞâ¢µ£ëÕÉêþÉåþÜäµÿ¥þñ║
        const maxDisplayPower = 2000; // µÿ¥þñ║ÕÅéÞÇâÕÇ╝
        const powerPercent = Math.min(1, entity.power / maxDisplayPower);
        const barWidth = size * 1.5;
        const barHeight = 4;
        const barX = x - barWidth / 2;
        const barY = y + size + 5;
        
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.ctx.fillRect(barX, barY, barWidth, barHeight);
        
        this.ctx.fillStyle = powerPercent > 0.3 ? '#4CAF50' : powerPercent > 0.1 ? '#FF9800' : '#F44336';
        this.ctx.fillRect(barX, barY, barWidth * powerPercent, barHeight);
        
        // Õ£¿Õ▒ÅÕ╣òþ®║Úù┤þ╗ÿÕêÂµûçÕ¡ù´╝êÚü┐ÕàìÚçìÕ¢▒´╝ëÔÇöÔÇöõ¢┐þö¿ baseSize þ╗ôÕÉê zoomLevel Þ«íþ«ùÕüÅþº╗
        this.drawSeagullInfoScreen(entity, x, y, baseSize, isControllable, zoomLevel, mainPlayer);
    },
    
    // Õ£¿Õ▒ÅÕ╣òþ®║Úù┤þ╗ÿÕêÂµÁÀÚ©Ñõ┐íµü»´╝êõ┐«ÕñìÚçìÕ¢▒þÜäÕà│Úö«´╝ë
    drawSeagullInfoScreen(entity, worldX, worldY, baseSize, isControllable, zoomLevel, mainPlayer) {
        this.ctx.save();
        
        // Úçìþ¢«ÕÅÿµìóÕê░Õ▒ÅÕ╣òÕØÉµáçþ│╗
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        
        // õ©Ä drawFrame õ┐Øµîüõ©ÇÞç┤þÜäþø©µ£║ÕüÅþº╗Þ«íþ«ù
        const cameraOffsetX = mainPlayer.velocityX * 10;
        const cameraOffsetY = mainPlayer.velocityY * 10;
        const maxOffset = 150;
        const actualOffsetX = Math.max(-maxOffset, Math.min(maxOffset, cameraOffsetX));
        const actualOffsetY = Math.max(-maxOffset, Math.min(maxOffset, cameraOffsetY));
        
        // ÞºåÕÅúÕÀªõ©èÞºÆ´╝êõ©ûþòîÕØÉµáç´╝ë
        const viewportOriginX = mainPlayer.x - actualOffsetX - this.gameWidth / (2 * zoomLevel);
        const viewportOriginY = mainPlayer.y - actualOffsetY - this.gameHeight / (2 * zoomLevel);
        
        // õ©ûþòî->Õ▒ÅÕ╣òÕØÉµáçÞ¢¼µìó
        const screenX = (worldX - viewportOriginX) * zoomLevel;
        const screenY = (worldY - viewportOriginY) * zoomLevel;
        
        // þí«õ┐ØµÁÀÚ©ÑÕ£¿Õ▒ÅÕ╣òÞîâÕø┤Õåà
        if (screenX >= -50 && screenX <= this.gameWidth + 50 && 
            screenY >= -50 && screenY <= this.gameHeight + 50) {
            
            const powerText = `${entity.power}`;
            const nameText = entity.name;
            
            this.ctx.font = 'bold 12px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            
            // µûçÕ¡ùþø©Õ»╣µÁÀÚ©ÑþÜäÕüÅþº╗´╝Üõ©ûþòîÕ░║Õ»© * zoomLevel
            const powerTextY = screenY - (baseSize * zoomLevel) - 15;
            const nameTextY = powerTextY - 15;
            
            // ÞâîµÖ»µíå
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            const powerTextWidth = this.ctx.measureText(powerText).width;
            this.ctx.fillRect(
                screenX - powerTextWidth / 2 - 3,
                powerTextY - 6,
                powerTextWidth + 6,
                12
            );
            
            // Þâ¢ÕèøÕÇ╝
            this.ctx.fillStyle = '#FFD700';
            this.ctx.fillText(powerText, screenX, powerTextY);
            
            // ÕÉìÕ¡ùÞâîµÖ»
            this.ctx.font = 'bold 10px Arial';
            const nameTextWidth = this.ctx.measureText(nameText).width;
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            this.ctx.fillRect(
                screenX - nameTextWidth / 2 - 3,
                nameTextY - 5,
                nameTextWidth + 6,
                10
            );
            
            // ÕÉìÕ¡ù
            this.ctx.fillStyle = isControllable ? '#FFD700' : '#FFF';
            this.ctx.fillText(nameText, screenX, nameTextY);
        }
        
        this.ctx.restore();
    },
    
    // þ╗ÿÕêÂµëçÞ┤Ø
    drawScallop(x, y, size, color, innerColor, zoomLevel, isGrowing, growthProgress, scallop) {
        const drawSize = size;  // Õ£¿õ©ûþòîÕØÉµáçþ│╗õ©¡´╝îõ©ìÚ£ÇÞªüÚóØÕñûþ╝®µö¥
        
        // µêÉÚò┐Õè¿þö╗´╝ÜÞäëÕè¿µòêµ×£
        let animationScale = 1.0;
        if (isGrowing && growthProgress !== undefined) {
            // õ¢┐þö¿µ¡úÕ╝ªµ│óÕêøÕ╗║ÞäëÕè¿µòêµ×£
            animationScale = 1.0 + Math.sin(growthProgress * Math.PI * 4) * 0.15;
        }
        
        const finalSize = drawSize * animationScale;
        
        // µëçÞ┤ØþÄïÕàëþÄ»µòêµ×£
        if (scallop && (scallop.isKing || scallop.isKingCandidate)) {
            this.ctx.save();
            const time = Date.now() / 1000;
            const glowSize = finalSize + 8 + Math.sin(time * 3) * 3;
            
            // ÕñûÕ▒éÚçæÞë▓ÕàëþÄ»
            const gradient = this.ctx.createRadialGradient(x, y, finalSize, x, y, glowSize);
            gradient.addColorStop(0, 'rgba(255, 215, 0, 0)');
            gradient.addColorStop(0.7, scallop.isKing ? 'rgba(255, 215, 0, 0.6)' : 'rgba(255, 105, 180, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(x, y, glowSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
            
            // µëçÞ┤ØþÄïµáçÞ«░
            if (scallop.isKing) {
                this.ctx.save();
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = '#FFD700';
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 3;
                this.ctx.strokeText('­ƒææ', x, y - finalSize - 15);
                this.ctx.fillText('­ƒææ', x, y - finalSize - 15);
                this.ctx.restore();
            }
        }
        
        // ÕÅÿÞ┤¿µëçÞ┤ØÞ¡ªÕæèµòêµ×£
        if (scallop && scallop.isSpoiled) {
            this.ctx.save();
            const time = Date.now() / 500;
            this.ctx.strokeStyle = `rgba(255, 0, 0, ${0.5 + Math.sin(time) * 0.3})`;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([5, 5]);
            this.ctx.beginPath();
            this.ctx.arc(x, y, finalSize + 5, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
            
            // µ»ÆµáçÞ«░
            this.ctx.font = 'bold 14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillStyle = '#FF0000';
            this.ctx.strokeStyle = '#000';
            this.ctx.lineWidth = 2;
            this.ctx.strokeText('Ôÿá', x, y - finalSize - 12);
            this.ctx.fillText('Ôÿá', x, y - finalSize - 12);
            this.ctx.restore();
        }
        
        // µêÉÚò┐ÕàëþÄ»µòêµ×£
        if (isGrowing && CONFIG.scallopGrowth.showGrowthEffect) {
            // ...existing code...
        }
            this.ctx.save();
            this.ctx.strokeStyle = `rgba(76, 175, 80, ${0.8 * (1 - growthProgress)})`;
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.arc(x, y, finalSize + 5 + growthProgress * 10, 0, Math.PI * 2);
            this.ctx.stroke();
            
            this.ctx.strokeStyle = `rgba(76, 175, 80, ${0.5 * (1 - growthProgress)})`;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(x, y, finalSize + 10 + growthProgress * 15, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.restore();
        }
        
        this.ctx.fillStyle = color;
        this.ctx.beginPath();
        this.ctx.arc(x, y, finalSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        // þ╗ÿÕêÂµëçÞ┤Øþ║╣þÉå
        this.ctx.strokeStyle = '#DDD';
        this.ctx.lineWidth = 1;
        const lineCount = Math.floor(size / 1.5);  // µá╣µì«ÕñºÕ░ÅÞ░âµò┤þ║╣þÉåþ║┐µØíµò░ÚçÅ
        for (let i = 0; i < lineCount; i++) {
            const angle = (i / lineCount) * Math.PI;
            this.ctx.beginPath();
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(x + Math.cos(angle) * finalSize, y + Math.sin(angle) * finalSize);
            this.ctx.stroke();
        }
        
        this.ctx.fillStyle = innerColor;
        this.ctx.beginPath();
        this.ctx.arc(x, y, finalSize * 0.6, 0, Math.PI * 2);
        this.ctx.fill();
        
        // µÀ╗ÕèáÕàëµ│¢µòêµ×£´╝êÕñºµëçÞ┤Øµø┤µÿÄµÿ¥´╝ë
        if (size >= 12) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.beginPath();
            this.ctx.arc(x - finalSize * 0.3, y - finalSize * 0.3, finalSize * 0.4, 0, Math.PI * 2);
            this.ctx.fill();
        }
    },
    
    // Õ£¿õ©ûþòîÕØÉµáçþ│╗õ©¡þ╗ÿÕêÂÞâ¢ÕèøÕÇ╝Þ¢¼þº╗µòêµ×£
    drawPowerTransferEffectsWorld(effects, zoomLevel, mainPlayer) {
        if (effects.length === 0) return;
        
        this.ctx.save();
        
        const viewportWidth = this.gameWidth / zoomLevel;
        const viewportHeight = this.gameHeight / zoomLevel;
        
        // Þ«íþ«ùÞºåÕÅúÞîâÕø┤
        const viewportLeft = mainPlayer.x - viewportWidth / 2;
        const viewportRight = mainPlayer.x + viewportWidth / 2;
        const viewportTop = mainPlayer.y - viewportHeight / 2;
        const viewportBottom = mainPlayer.y + viewportHeight / 2;
        
        // þ╗ÿÕêÂµ»Åõ©¬µòêµ×£
        effects.forEach(effect => {
            // µúÇµƒÑµòêµ×£µÿ»ÕÉªÕ£¿ÞºåÕÅúÕåà
            if (effect.x >= viewportLeft && effect.x <= viewportRight &&
                effect.y >= viewportTop && effect.y <= viewportBottom) {
                
                // µá╣µì«þöƒÕæ¢ÕÇ╝Þ«¥þ¢«ÚÇÅµÿÄÕ║ª
                const alpha = effect.alpha || Math.min(1, effect.life * 2);
                
                // þ╗ÿÕêÂµûçÕ¡ù
                this.ctx.fillStyle = this.addAlphaToColor(effect.color, alpha);
                this.ctx.font = `${14 * effect.scale}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(effect.text, effect.x, effect.y);
            }
        });
        
        this.ctx.restore();
    },
    
    // Õ£¿Õ▒ÅÕ╣òÕØÉµáçþ│╗õ©¡þ╗ÿÕêÂÞâ¢ÕèøÕÇ╝Þ¢¼þº╗µòêµ×£´╝êõ╝ÿÕîûþëêµ£¼´╝ë
    drawPowerTransferEffectsScreen(effects, zoomLevel, mainPlayer) {
        if (effects.length === 0) return;
        
        this.ctx.save();
        
        // ÕêçµìóÕê░Õ▒ÅÕ╣òÕØÉµáçþ│╗
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        
        // õ¢┐þö¿õ©Ä drawFrame õ©ÇÞç┤þÜäþø©µ£║ÕüÅþº╗
        const cameraOffsetX = mainPlayer.velocityX * 10;
        const cameraOffsetY = mainPlayer.velocityY * 10;
        const maxOffset = 150;
        const actualOffsetX = Math.max(-maxOffset, Math.min(maxOffset, cameraOffsetX));
        const actualOffsetY = Math.max(-maxOffset, Math.min(maxOffset, cameraOffsetY));
        
        // ÞºåÕÅúÕÀªõ©èÞºÆ´╝êõ©ûþòîÕØÉµáç´╝ë
        const viewportOriginX = mainPlayer.x - actualOffsetX - this.gameWidth / (2 * zoomLevel);
        const viewportOriginY = mainPlayer.y - actualOffsetY - this.gameHeight / (2 * zoomLevel);
        
        // Õ▒ÅÕ╣òÞîâÕø┤
        const screenLeft = 0;
        const screenRight = this.gameWidth;
        const screenTop = 0;
        const screenBottom = this.gameHeight;
        
        // þ╗ÿÕêÂµ»Åõ©¬ÕÅ»ÞºüþÜäµòêµ×£
        effects.forEach(effect => {
            // õ©ûþòî->Õ▒ÅÕ╣òÕØÉµáçÞ¢¼µìó
            const screenX = (effect.x - viewportOriginX) * zoomLevel;
            const screenY = (effect.y - viewportOriginY) * zoomLevel;
            
            if (screenX >= screenLeft - 50 && screenX <= screenRight + 50 &&
                screenY >= screenTop - 50 && screenY <= screenBottom + 50) {
                
                // õ¢┐þö¿ effect.alpha ÞÇîõ©ìµÿ»Úçìµû░Þ«íþ«ù´╝îþí«õ┐Øõ©Äµø┤µû░ÚÇ╗Þ¥æõ©ÇÞç┤
                const alpha = effect.alpha;
                
                // Õ¢ôÚÇÅµÿÄÕ║ªÕ¥êõ¢ÄµùÂ´╝îþø┤µÄÑÞÀ│Þ┐çþ╗ÿÕêÂ
                if (alpha < 0.05) return;
                
                this.ctx.font = `bold ${14 * effect.scale}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                const text = effect.text;
                const textWidth = this.ctx.measureText(text).width;
                const textHeight = 14 * effect.scale;
                
                this.ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.5})`;
                this.ctx.fillRect(
                    screenX - textWidth / 2 - 4,
                    screenY - textHeight / 2 - 2,
                    textWidth + 8,
                    textHeight + 4
                );
                
                this.ctx.fillStyle = this.addAlphaToColor(effect.color, alpha);
                this.ctx.fillText(text, screenX, screenY);
                
                // ÕÅ¬Õ£¿þöƒÕæ¢ÕÇ╝Õ¥êÚ½ÿµùÂµÿ¥þñ║ÕÅæÕàëµòêµ×£
                if (effect.life > 0.8) {
                    this.ctx.shadowColor = effect.color;
                    this.ctx.shadowBlur = 5 * effect.scale * alpha;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 0;
                    this.ctx.fillText(text, screenX, screenY);
                    this.ctx.shadowBlur = 0;
                }
            }
        });
        
        this.ctx.restore();
    },
    
    // õ©║Úó£Þë▓µÀ╗ÕèáÚÇÅµÿÄÕ║ª
    addAlphaToColor(color, alpha) {
        // Õªéµ×£Úó£Þë▓ÕÀ▓þ╗Åµÿ»rgbaµá╝Õ╝Å
        if (color.startsWith('rgba')) {
            return color.replace(/[\d\.]+\)$/g, alpha + ')');
        }
        // Õªéµ×£Úó£Þë▓µÿ»rgbµá╝Õ╝Å
        else if (color.startsWith('rgb')) {
            return color.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        // Õªéµ×£Úó£Þë▓µÿ»ÕìüÕà¡Þ┐øÕêÂµá╝Õ╝Å
        else if (color.startsWith('#')) {
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        // Ú╗ÿÞ«ñÞ┐öÕø×ÕÄƒÞë▓
        return color;
    },
    
    // þ╗ÿÕêÂµ░┤ÞâîµÖ»
    drawWaterBackground() {
        this.ctx.save();
        this.ctx.globalAlpha = 0.3;
        
        const time = Date.now() / 1000;
        const waveCount = 10;
        
        for (let i = 0; i < waveCount; i++) {
            const offset = i * 0.5;
            const radius = 200 + Math.sin(time + offset) * 30;
            const x = (CONFIG.worldWidth / waveCount) * i;
            const y = CONFIG.worldHeight / 2;
            
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(x, y, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    },
    
    // þ╗ÿÕêÂµ©©µêÅõ┐íµü»´╝êÕ▒ÅÕ╣òþ®║Úù┤´╝ë
    drawGameInfo(playerPower, playerSize, scallopsEaten, gameTime) {
        const mainPlayer = EntityManager.players[0];
        if (!mainPlayer || mainPlayer.isDead) return;
        
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        
        // þ╗ÿÕêÂõ┐íµü»ÚØóµØ┐ÞâîµÖ»
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(10, 10, 150, 80);
        
        // þ╗ÿÕêÂõ┐íµü»µûçÕ¡ù
        this.ctx.fillStyle = '#FFD700';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'left';
        this.ctx.textBaseline = 'middle';
        
        this.ctx.fillText(`Þâ¢ÕèøÕÇ╝: ${playerPower}`, 20, 30);
        this.ctx.fillText(`ÕñºÕ░Å: ${playerSize.toFixed(1)}`, 20, 50);
        this.ctx.fillText(`µëçÞ┤Ø: ${scallopsEaten}`, 20, 70);
        this.ctx.fillText(`µùÂÚù┤: ${Math.floor(gameTime)}s`, 20, 90);
        
        this.ctx.restore();
    }
};

// Õ»╝Õç║þ╗ÿÕêÂþ│╗þ╗ƒ
window.DrawingSystem = DrawingSystem;
